"""
Integration layer for Pydantic AI agents.

This module provides a unified interface to the pydantic_ai_agents package,
handling configuration, initialization, and execution of the various agents.
"""

import os
import sys
from pathlib import Path
from typing import Optional, Dict, Any, List
import logging

# Add parent directories to path to import from existing packages
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from tui.config import get_settings
from tui.utils.errors import APIKeyError, ModelError, ValidationError, APILimitError

# Import the existing pydantic_ai_agents
try:
    from pydantic_ai_agents.agents import (
        generate_video_prompt_ideas_simple,
        generate_video_prompt_ideas_viral,
        generate_variations_for_topic,
    )
    from pydantic_ai_agents.schemas import IdeaList, VideoPromptIdea
    from pydantic_ai_agents.config import Settings as PydanticAISettings
    
    PYDANTIC_AI_AVAILABLE = True
except ImportError as e:
    logging.warning(f"Failed to import pydantic_ai_agents: {e}")
    PYDANTIC_AI_AVAILABLE = False
    
    # Create mock classes for development
    class IdeaList:
        def __init__(self, ideas=None):
            self.ideas = ideas or []
    
    class VideoPromptIdea:
        def __init__(self, title="", description="", sources=None, trend_score=None):
            self.title = title
            self.description = description
            self.sources = sources or []
            self.trend_score = trend_score


logger = logging.getLogger(__name__)


class PydanticAIManager:
    """
    Manager class for Pydantic AI agents.
    
    This class provides a unified interface to all Pydantic AI functionality,
    handling configuration, error management, and result processing.
    """
    
    def __init__(self):
        """Initialize the Pydantic AI manager."""
        self.settings = get_settings()
        self._validate_setup()
    
    def _validate_setup(self) -> None:
        """Validate that the setup is correct for Pydantic AI operations."""
        if not PYDANTIC_AI_AVAILABLE:
            raise ImportError("Pydantic AI agents package is not available")
        
        if not self.settings.get_google_api_key():
            raise APIKeyError("google", "Google API key is required for Pydantic AI operations")
    
    def _setup_environment(self) -> None:
        """Set up environment variables for the pydantic_ai_agents package."""
        # Set environment variables that pydantic_ai_agents expects
        if self.settings.get_google_api_key():
            os.environ["GOOGLE_API_KEY"] = self.settings.get_google_api_key()
        
        if self.settings.get_tavily_api_key():
            os.environ["TAVILY_API_KEY"] = self.settings.get_tavily_api_key()
        
        if self.settings.get_exa_api_key():
            os.environ["EXA_API_KEY"] = self.settings.get_exa_api_key()
        
        if self.settings.get_linkup_api_key():
            os.environ["LINKUP_API_KEY"] = self.settings.get_linkup_api_key()
        
        # Set other configuration
        os.environ["PYA_MODEL"] = self.settings.PYA_MODEL
        os.environ["DEFAULT_NUM_IDEAS"] = str(self.settings.DEFAULT_NUM_IDEAS)
        os.environ["PYA_RETRIES"] = str(self.settings.PYA_RETRIES)
        os.environ["PYA_RETRY_BACKOFF_S"] = str(self.settings.PYA_RETRY_BACKOFF_S)
    
    async def generate_simple_ideas(self, topic: str, num_ideas: Optional[int] = None) -> IdeaList:
        """
        Generate video prompt ideas using simple search.
        
        Args:
            topic: The topic or query to generate ideas for
            num_ideas: Number of ideas to generate (uses default if None)
        
        Returns:
            IdeaList containing the generated ideas
        
        Raises:
            ValidationError: If topic is invalid
            APIKeyError: If required API keys are missing
            ModelError: If model execution fails
            APILimitError: If API limits are exceeded
        """
        if not topic or not topic.strip():
            raise ValidationError("topic", topic, "Topic cannot be empty")
        
        topic = topic.strip()
        
        if not PYDANTIC_AI_AVAILABLE:
            # Return mock data for development
            return IdeaList(ideas=[
                VideoPromptIdea(
                    title=f"Mock idea for: {topic}",
                    description=f"This is a mock video prompt idea generated for the topic '{topic}'. In a real implementation, this would be generated by the Pydantic AI agents.",
                    sources=["mock_source"],
                    trend_score=0.8
                )
            ])
        
        try:
            self._setup_environment()
            result = generate_video_prompt_ideas_simple(topic, num_ideas)
            return result
        
        except Exception as e:
            logger.error(f"Failed to generate simple ideas: {e}", exc_info=True)
            self._handle_error(e)
    
    async def generate_viral_ideas(self, query: Optional[str] = None, num_ideas: Optional[int] = None) -> IdeaList:
        """
        Generate viral-oriented video prompt ideas.
        
        Args:
            query: Optional query to guide topic selection
            num_ideas: Number of ideas to generate (uses default if None)
        
        Returns:
            IdeaList containing the generated viral ideas
        
        Raises:
            APIKeyError: If required API keys are missing
            ModelError: If model execution fails
            APILimitError: If API limits are exceeded
        """
        if not PYDANTIC_AI_AVAILABLE:
            # Return mock data for development
            return IdeaList(ideas=[
                VideoPromptIdea(
                    title=f"Mock viral idea",
                    description=f"This is a mock viral video prompt idea. Query: {query or 'No specific query'}",
                    sources=["mock_viral_source"],
                    trend_score=0.9
                )
            ])
        
        try:
            self._setup_environment()
            result = generate_video_prompt_ideas_viral(query, num_ideas)
            return result
        
        except Exception as e:
            logger.error(f"Failed to generate viral ideas: {e}", exc_info=True)
            self._handle_error(e)
    
    async def generate_topic_variations(self, topic: str, num_ideas: Optional[int] = None) -> IdeaList:
        """
        Generate variations for a specific topic.
        
        Args:
            topic: The base topic to create variations for
            num_ideas: Number of variations to generate (uses default if None)
        
        Returns:
            IdeaList containing the topic variations
        
        Raises:
            ValidationError: If topic is invalid
            APIKeyError: If required API keys are missing
            ModelError: If model execution fails
            APILimitError: If API limits are exceeded
        """
        if not topic or not topic.strip():
            raise ValidationError("topic", topic, "Topic cannot be empty")
        
        topic = topic.strip()
        
        if not PYDANTIC_AI_AVAILABLE:
            # Return mock data for development
            return IdeaList(ideas=[
                VideoPromptIdea(
                    title=f"Variation 1: {topic}",
                    description=f"This is a mock variation of the topic '{topic}'. Style: Cinematic",
                    sources=["mock_variation_source"],
                    trend_score=0.7
                ),
                VideoPromptIdea(
                    title=f"Variation 2: {topic}",
                    description=f"This is another mock variation of '{topic}'. Style: Documentary",
                    sources=["mock_variation_source"],
                    trend_score=0.6
                )
            ])
        
        try:
            self._setup_environment()
            result = generate_variations_for_topic(topic, num_ideas)
            return result
        
        except Exception as e:
            logger.error(f"Failed to generate topic variations: {e}", exc_info=True)
            self._handle_error(e)
    
    def _handle_error(self, error: Exception) -> None:
        """
        Handle and re-raise errors with appropriate TUI error types.
        
        Args:
            error: The original error to handle
        
        Raises:
            Appropriate TUI error type based on the original error
        """
        error_msg = str(error).lower()
        
        # Check for API key errors
        if "api key" in error_msg or "authentication" in error_msg:
            if "google" in error_msg:
                raise APIKeyError("google", str(error))
            elif "tavily" in error_msg:
                raise APIKeyError("tavily", str(error))
            else:
                raise APIKeyError("unknown", str(error))
        
        # Check for rate limiting errors
        if "rate limit" in error_msg or "quota" in error_msg or "429" in error_msg:
            service = "google"  # Default to Google since that's the main service
            if "tavily" in error_msg:
                service = "tavily"
            raise APILimitError(service, "rate", str(error))
        
        # Check for model errors
        if "model" in error_msg or "gemini" in error_msg:
            raise ModelError(self.settings.PYA_MODEL, str(error))
        
        # Re-raise as generic model error for other cases
        raise ModelError(self.settings.PYA_MODEL, str(error))
    
    def get_available_models(self) -> List[str]:
        """
        Get a list of available models for Pydantic AI.
        
        Returns:
            List of available model names
        """
        return [
            "gemini-2.5-flash",
            "gemini-2.5-pro", 
            "gemini-2.0-flash",
            "gemini-1.5-pro",
            "gemini-1.5-flash"
        ]
    
    def get_status(self) -> Dict[str, Any]:
        """
        Get the current status of Pydantic AI integration.
        
        Returns:
            Dictionary containing status information
        """
        status = {
            "available": PYDANTIC_AI_AVAILABLE,
            "google_api_key": bool(self.settings.get_google_api_key()),
            "tavily_api_key": bool(self.settings.get_tavily_api_key()),
            "exa_api_key": bool(self.settings.get_exa_api_key()),
            "linkup_api_key": bool(self.settings.get_linkup_api_key()),
            "current_model": self.settings.PYA_MODEL,
            "default_num_ideas": self.settings.DEFAULT_NUM_IDEAS,
            "retries": self.settings.PYA_RETRIES,
        }
        
        # Check if minimum requirements are met
        status["ready"] = (
            status["available"] and 
            status["google_api_key"]
        )
        
        return status
    
    def validate_configuration(self) -> List[str]:
        """
        Validate the current configuration and return any issues.
        
        Returns:
            List of validation error messages (empty if no issues)
        """
        issues = []
        
        if not PYDANTIC_AI_AVAILABLE:
            issues.append("Pydantic AI agents package is not available")
        
        if not self.settings.get_google_api_key():
            issues.append("Google API key is not configured")
        
        if self.settings.PYA_MODEL not in self.get_available_models():
            issues.append(f"Model '{self.settings.PYA_MODEL}' is not in the list of available models")
        
        if self.settings.DEFAULT_NUM_IDEAS < 1 or self.settings.DEFAULT_NUM_IDEAS > 100:
            issues.append("Default number of ideas should be between 1 and 100")
        
        return issues
